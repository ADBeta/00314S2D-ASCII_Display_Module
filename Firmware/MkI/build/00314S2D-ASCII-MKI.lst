
build/00314S2D-ASCII-MKI.elf:     file format elf32-littleriscv


Disassembly of section .init:

00000000 <InterruptVector>:

#if defined( CH32V003 ) || defined( CH32X03x )

void InterruptVectorDefault()
{
	asm volatile( "\n\
   0:	0e60006f          	j	e6 <handle_reset>
   4:	00000000          	.word	0x00000000
   8:	0000015e          	.word	0x0000015e
   c:	0000015c          	.word	0x0000015c
	...
  30:	00000384          	.word	0x00000384
  34:	00000000          	.word	0x00000000
  38:	0000015c          	.word	0x0000015c
  3c:	00000000          	.word	0x00000000
  40:	0000015c          	.word	0x0000015c
  44:	0000015c          	.word	0x0000015c
  48:	0000015c          	.word	0x0000015c
  4c:	0000015c          	.word	0x0000015c
  50:	0000015c          	.word	0x0000015c
  54:	0000015c          	.word	0x0000015c
  58:	0000015c          	.word	0x0000015c
  5c:	0000015c          	.word	0x0000015c
  60:	0000015c          	.word	0x0000015c
  64:	0000015c          	.word	0x0000015c
  68:	0000015c          	.word	0x0000015c
  6c:	0000015c          	.word	0x0000015c
  70:	0000015c          	.word	0x0000015c
  74:	0000015c          	.word	0x0000015c
  78:	0000015c          	.word	0x0000015c
  7c:	0000015c          	.word	0x0000015c
  80:	000003b6          	.word	0x000003b6
  84:	0000015c          	.word	0x0000015c
  88:	0000015c          	.word	0x0000015c
  8c:	0000015c          	.word	0x0000015c
  90:	0000015c          	.word	0x0000015c
  94:	0000015c          	.word	0x0000015c
  98:	0000015c          	.word	0x0000015c
  9c:	0000                	unimp
	...

Disassembly of section .text:

000000a0 <gpio_set_mode.constprop.0>:
	
	// Make array of uint8_t from [pin] enum. See definition for details
	uint8_t *byte = (uint8_t *)&pin;
	
	// Set the RCC Register to enable clock on the specified port
	GPIO_RCC->APB2PCENR |= (RCC_APB2PCENR_AFIO | (RCC_APB2PCENR_IOPxEN << byte[0]));
  a0:	400216b7          	lui	a3,0x40021
  a4:	4e90                	lw	a2,24(a3)
  a6:	4791                	li	a5,4
  a8:	00a797b3          	sll	a5,a5,a0
  ac:	8fd1                	or	a5,a5,a2
  ae:	0017e793          	ori	a5,a5,1
  b2:	ce9c                	sw	a5,24(a3)
  b4:	0ff57713          	zext.b	a4,a0

	// Clear then set the GPIO Config Register
	GPIO_PORT_MAP[ byte[0] ]->CFGLR &=        ~(0x0F  << (4 * byte[1]));
  b8:	070a                	slli	a4,a4,0x2
  ba:	52c00793          	li	a5,1324
  be:	97ba                	add	a5,a5,a4
  c0:	4398                	lw	a4,0(a5)
  c2:	8119                	srli	a0,a0,0x6
  c4:	3fc57513          	andi	a0,a0,1020
  c8:	4314                	lw	a3,0(a4)
  ca:	47bd                	li	a5,15
  cc:	00a797b3          	sll	a5,a5,a0
  d0:	fff7c793          	not	a5,a5
  d4:	8ff5                	and	a5,a5,a3
  d6:	c31c                	sw	a5,0(a4)
	GPIO_PORT_MAP[ byte[0] ]->CFGLR |=  (mode & 0x0F) << (4 * byte[1]);
  d8:	4314                	lw	a3,0(a4)
  da:	4785                	li	a5,1
  dc:	00a797b3          	sll	a5,a5,a0
  e0:	8fd5                	or	a5,a5,a3
  e2:	c31c                	sw	a5,0(a4)

	// If [mode] is INPUT_PULLUP or INPUT_PULLDOWN, set the [OUTDR] Register
	if(mode == INPUT_PULLUP || mode == INPUT_PULLDOWN)
		gpio_digital_write(pin, mode >> 4);
}
  e4:	8082                	ret

000000e6 <handle_reset>:
	asm volatile( ".option   pop;\n");
}

void handle_reset()
{
	asm volatile( "\n\
  e6:	20000197          	auipc	gp,0x20000
  ea:	71a18193          	addi	gp,gp,1818 # 20000800 <__global_pointer$>
  ee:	00018113          	mv	sp,gp
  f2:	08000513          	li	a0,128
  f6:	30051073          	csrw	mstatus,a0
  fa:	468d                	li	a3,3
  fc:	00000517          	auipc	a0,0x0
 100:	f0450513          	addi	a0,a0,-252 # 0 <InterruptVector>
 104:	8d55                	or	a0,a0,a3
 106:	30551073          	csrw	mtvec,a0
	csrw mtvec, a0\n" 
	: : : "a0", "a3", "memory");

	// Careful: Use registers to prevent overwriting of self-data.
	// This clears out BSS.
asm volatile(
 10a:	20000517          	auipc	a0,0x20000
 10e:	ef650513          	addi	a0,a0,-266 # 20000000 <char_idx.0>
 112:	81418593          	addi	a1,gp,-2028 # 20000014 <_ebss>
 116:	4601                	li	a2,0
 118:	00b55663          	bge	a0,a1,124 <handle_reset+0x3e>
 11c:	c110                	sw	a2,0(a0)
 11e:	0511                	addi	a0,a0,4
 120:	feb54ee3          	blt	a0,a1,11c <handle_reset+0x36>
 124:	57800513          	li	a0,1400
 128:	20000597          	auipc	a1,0x20000
 12c:	ed858593          	addi	a1,a1,-296 # 20000000 <char_idx.0>
 130:	20000617          	auipc	a2,0x20000
 134:	ed060613          	addi	a2,a2,-304 # 20000000 <char_idx.0>
 138:	00c58863          	beq	a1,a2,148 <handle_reset+0x62>
 13c:	4114                	lw	a3,0(a0)
 13e:	c194                	sw	a3,0(a1)
 140:	0511                	addi	a0,a0,4
 142:	0591                	addi	a1,a1,4
 144:	fec59ae3          	bne	a1,a2,138 <handle_reset+0x52>
);

#if defined( FUNCONF_SYSTICK_USE_HCLK ) && FUNCONF_SYSTICK_USE_HCLK
	SysTick->CTLR = 5;
#else
	SysTick->CTLR = 1;
 148:	e000f7b7          	lui	a5,0xe000f
 14c:	4705                	li	a4,1
 14e:	c398                	sw	a4,0(a5)
#endif

	// set mepc to be main as the root app.
asm volatile(
 150:	1c000793          	li	a5,448
 154:	34179073          	csrw	mepc,a5
 158:	30200073          	mret

0000015c <ADC1_IRQHandler>:
	asm volatile( "1: j 1b" );
 15c:	a001                	j	15c <ADC1_IRQHandler>

0000015e <NMI_Handler>:
	RCC->INTR |= RCC_CSSC;	// clear the clock security int flag
 15e:	40021737          	lui	a4,0x40021
 162:	471c                	lw	a5,8(a4)
 164:	008006b7          	lui	a3,0x800
 168:	8fd5                	or	a5,a5,a3
 16a:	c71c                	sw	a5,8(a4)

0000016c <SystemInit>:
	// CH32V003 flash latency
#if defined(CH32X03x)
	FLASH->ACTLR = FLASH_ACTLR_LATENCY_2;                   // +2 Cycle Latency (Recommended per TRM)
#elif defined(CH32V003)
	#if FUNCONF_SYSTEM_CORE_CLOCK > 25000000
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;               // +1 Cycle Latency
 16c:	400227b7          	lui	a5,0x40022
 170:	4705                	li	a4,1
 172:	c398                	sw	a4,0(a5)
#if defined(FUNCONF_USE_HSI) && FUNCONF_USE_HSI
	#if defined(CH32V30x) || defined(CH32V20x) || defined(CH32V10x)
		EXTEN->EXTEN_CTR |= EXTEN_PLL_HSI_PRE;
	#endif
	#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL
		RCC->CFGR0 = BASE_CFGR0;
 174:	400217b7          	lui	a5,0x40021
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 178:	01080737          	lui	a4,0x1080
		RCC->CFGR0 = BASE_CFGR0;
 17c:	0007a223          	sw	zero,4(a5) # 40021004 <__global_pointer$+0x20020804>
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 180:	08170713          	addi	a4,a4,129 # 1080081 <lib_uart.c.02352773+0x107cf16>
 184:	c398                	sw	a4,0(a5)
	#else
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;       		// +1 Cycle Latency
	#endif
#endif

	RCC->INTR  = 0x009F0000;                               // Clear PLL, CSSC, HSE, HSI and LSI ready flags.
 186:	009f0737          	lui	a4,0x9f0
 18a:	c798                	sw	a4,8(a5)

#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL
	while((RCC->CTLR & RCC_PLLRDY) == 0);                       	// Wait till PLL is ready
 18c:	4398                	lw	a4,0(a5)
 18e:	00671693          	slli	a3,a4,0x6
 192:	fe06dde3          	bgez	a3,18c <SystemInit+0x20>
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 196:	43d8                	lw	a4,4(a5)
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 198:	400216b7          	lui	a3,0x40021
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 19c:	9b71                	andi	a4,a4,-4
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
 19e:	00276713          	ori	a4,a4,2
 1a2:	c3d8                	sw	a4,4(a5)
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 1a4:	4721                	li	a4,8
 1a6:	42dc                	lw	a5,4(a3)
 1a8:	8bb1                	andi	a5,a5,12
 1aa:	fee79ee3          	bne	a5,a4,1a6 <SystemInit+0x3a>
	*DMDATA1 = 0x0;
 1ae:	e00007b7          	lui	a5,0xe0000
 1b2:	0e07ac23          	sw	zero,248(a5) # e00000f8 <__global_pointer$+0xbffff8f8>
	*DMDATA0 = 0x80;
 1b6:	08000713          	li	a4,128
 1ba:	0ee7aa23          	sw	a4,244(a5)
	SetupUART( UART_BRR );
#endif
#if defined( FUNCONF_USE_DEBUGPRINTF ) && FUNCONF_USE_DEBUGPRINTF
	SetupDebugPrintf();
#endif
}
 1be:	8082                	ret

000001c0 <main>:
/// @return None
static void disp_refresh(void);

/*** Main ********************************************************************/
int main(void)
{
 1c0:	1131                	addi	sp,sp,-20
 1c2:	c426                	sw	s1,8(sp)
 1c4:	c806                	sw	ra,16(sp)
 1c6:	c622                	sw	s0,12(sp)
	SystemInit();
 1c8:	3755                	jal	16c <SystemInit>

/*** Functions ***************************************************************/
static void systick_init(void)
{
	// Reset any pre-existing configuration
	SysTick->CTLR = 0x0000;
 1ca:	e000f7b7          	lui	a5,0xe000f
	
	// Set the compare register to trigger once per millisecond
	SysTick->CMP = SYSTICK_ONE_MILLISECOND - 1;
 1ce:	6731                	lui	a4,0xc
	SysTick->CTLR = 0x0000;
 1d0:	0007a023          	sw	zero,0(a5) # e000f000 <__global_pointer$+0xc000e800>
	SysTick->CMP = SYSTICK_ONE_MILLISECOND - 1;
 1d4:	b7f70713          	addi	a4,a4,-1153 # bb7f <lib_uart.c.02352773+0x8a14>
 1d8:	cb98                	sw	a4,16(a5)

	// Reset the Count Register, and the global millis counter to 0
	SysTick->CNT = 0x00000000;
 1da:	0007a423          	sw	zero,8(a5)
	g_systick_millis = 0x00000000;
 1de:	8001a823          	sw	zero,-2032(gp) # 20000010 <g_systick_millis>
	
	// Set the SysTick Configuration
	// NOTE: By not setting SYSTICK_CTLR_STRE, we maintain compatibility with
	// busywait delay funtions used by ch32v003_fun.
	SysTick->CTLR |= SYSTICK_CTLR_STE   |  // Enable Counter
 1e2:	4398                	lw	a4,0(a5)
 * @param   IRQn - Interrupt Numbers
 * @return  none
 */
RV_STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
	NVIC->IENR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));
 1e4:	6685                	lui	a3,0x1
 1e6:	00776713          	ori	a4,a4,7
 1ea:	c398                	sw	a4,0(a5)
 1ec:	e000e737          	lui	a4,0xe000e
 1f0:	10d72023          	sw	a3,256(a4) # e000e100 <__global_pointer$+0xc000d900>
	uint32_t targend = SysTick->CNT + n;
 1f4:	4794                	lw	a3,8(a5)
 1f6:	002dc737          	lui	a4,0x2dc
 1fa:	6c070713          	addi	a4,a4,1728 # 2dc6c0 <lib_uart.c.02352773+0x2d9555>
 1fe:	96ba                	add	a3,a3,a4
	while( ((int32_t)( SysTick->CNT - targend )) < 0 );
 200:	4798                	lw	a4,8(a5)
 202:	8f15                	sub	a4,a4,a3
 204:	fe074ee3          	bltz	a4,200 <main+0x40>
 208:	53c00793          	li	a5,1340
	// TODO: Using FLASH, set the option bit to dsiable the NRST Pin

	// Set all Segment GPIO to OUTPUT, LOW
	for(uint8_t seg_pin = 0; seg_pin < 15; seg_pin++)
	{
		gpio_set_mode(segment_pin[seg_pin], OUTPUT_10MHZ_PP);
 20c:	4388                	lw	a0,0(a5)
 20e:	c23e                	sw	a5,4(sp)
inline void gpio_digital_write(const GPIO_PIN pin, const GPIO_STATE state)
{
	// Make array of uint8_t from [pin] enum. See definition for details
	uint8_t *byte = (uint8_t *)&pin;

	uint32_t mask = 0x01 << byte[1];          // Shift by pin number
 210:	4405                	li	s0,1
 212:	c02a                	sw	a0,0(sp)
 214:	3571                	jal	a0 <gpio_set_mode.constprop.0>
 216:	4502                	lw	a0,0(sp)
	if(state == GPIO_LOW) mask = mask << 16;  // Shift by 16 if LOW, to Reset

	GPIO_PORT_MAP[ byte[0] ]->BSHR = mask;
 218:	52c00693          	li	a3,1324
	uint32_t mask = 0x01 << byte[1];          // Shift by pin number
 21c:	00855713          	srli	a4,a0,0x8
	GPIO_PORT_MAP[ byte[0] ]->BSHR = mask;
 220:	0ff57513          	zext.b	a0,a0
 224:	050a                	slli	a0,a0,0x2
 226:	96aa                	add	a3,a3,a0
 228:	4294                	lw	a3,0(a3)
	uint32_t mask = 0x01 << byte[1];          // Shift by pin number
 22a:	00e41733          	sll	a4,s0,a4
	if(state == GPIO_LOW) mask = mask << 16;  // Shift by 16 if LOW, to Reset
 22e:	0742                	slli	a4,a4,0x10
	for(uint8_t seg_pin = 0; seg_pin < 15; seg_pin++)
 230:	4792                	lw	a5,4(sp)
	GPIO_PORT_MAP[ byte[0] ]->BSHR = mask;
 232:	ca98                	sw	a4,16(a3)
 234:	52c00713          	li	a4,1324
 238:	c03a                	sw	a4,0(sp)
 23a:	0791                	addi	a5,a5,4
 23c:	57800713          	li	a4,1400
 240:	fcf716e3          	bne	a4,a5,20c <main+0x4c>
		gpio_digital_write(segment_pin[seg_pin], GPIO_LOW);
	}

	// Set the Display Control Pin to OUTPUT, LOW
	gpio_set_mode(digit_pin, OUTPUT_10MHZ_PP);
 244:	70300513          	li	a0,1795
 248:	3da1                	jal	a0 <gpio_set_mode.constprop.0>
 24a:	400117b7          	lui	a5,0x40011
 24e:	40078793          	addi	a5,a5,1024 # 40011400 <__global_pointer$+0x20010c00>
 252:	00800737          	lui	a4,0x800
 256:	cb98                	sw	a4,16(a5)

/*** Initialiser *************************************************************/
uart_err_t uart_init(const uart_config_t *conf)
{	
	// Enable UART1 Clock
	RCC->APB2PCENR |= RCC_APB2Periph_USART1;
 258:	40021737          	lui	a4,0x40021
 25c:	4f14                	lw	a3,24(a4)
 25e:	6611                	lui	a2,0x4
	gpio_digital_write(digit_pin, GPIO_LOW);

	// Set the global display data to 0
	g_seg_data[0] = 0x0000;
 260:	20000337          	lui	t1,0x20000
 264:	00032223          	sw	zero,4(t1) # 20000004 <g_seg_data>
 268:	8ed1                	or	a3,a3,a2
 26a:	cf14                	sw	a3,24(a4)
	// Enable the UART GPIO Port, and the Alternate Function IO Flag
	RCC->APB2PCENR |= UART_TXRX_PORT_RCC | RCC_APB2Periph_AFIO;
 26c:	4f14                	lw	a3,24(a4)

	// Reset, then set the AFIO Register depending on UART_PINOUT selected
	AFIO->PCFR1 &= UART_AFIO_RESET_MASK;
 26e:	ffe00637          	lui	a2,0xffe00
 272:	166d                	addi	a2,a2,-5 # ffdffffb <__global_pointer$+0xdfdff7fb>
	RCC->APB2PCENR |= UART_TXRX_PORT_RCC | RCC_APB2Periph_AFIO;
 274:	0216e693          	ori	a3,a3,33
 278:	cf14                	sw	a3,24(a4)
	AFIO->PCFR1 &= UART_AFIO_RESET_MASK;
 27a:	40010737          	lui	a4,0x40010
 27e:	4354                	lw	a3,4(a4)
 280:	8ef1                	and	a3,a3,a2
 282:	c354                	sw	a3,4(a4)
	AFIO->PCFR1 |= UART_AFIO_MASK;
 284:	4354                	lw	a3,4(a4)
	// Enable the UART RXNE Interrupt
	USART1->CTLR1 |= USART_CTLR1_RXNEIE;
	NVIC_EnableIRQ(USART1_IRQn);
	
	// Enable the UART
	USART1->CTLR1 |= CTLR1_UE_Set;
 286:	6609                	lui	a2,0x2
	AFIO->PCFR1 |= UART_AFIO_MASK;
 288:	c354                	sw	a3,4(a4)
	UART_TXRX_PORT->CFGLR &= ~(0x0F << (4 * UART_PIN_TX));
 28a:	4398                	lw	a4,0(a5)
 28c:	ff1006b7          	lui	a3,0xff100
 290:	16fd                	addi	a3,a3,-1 # ff0fffff <__global_pointer$+0xdf0ff7ff>
 292:	8f75                	and	a4,a4,a3
 294:	c398                	sw	a4,0(a5)
	UART_TXRX_PORT->CFGLR |= (GPIO_Speed_10MHz | GPIO_CNF_OUT_PP_AF) << (4 * UART_PIN_TX);	
 296:	4398                	lw	a4,0(a5)
 298:	009006b7          	lui	a3,0x900
 29c:	8f55                	or	a4,a4,a3
 29e:	c398                	sw	a4,0(a5)
	UART_TXRX_PORT->CFGLR &= ~(0x0F << (4 * UART_PIN_RX));
 2a0:	4398                	lw	a4,0(a5)
 2a2:	f10006b7          	lui	a3,0xf1000
 2a6:	16fd                	addi	a3,a3,-1 # f0ffffff <__global_pointer$+0xd0fff7ff>
 2a8:	8f75                	and	a4,a4,a3
 2aa:	c398                	sw	a4,0(a5)
	UART_TXRX_PORT->CFGLR |= GPIO_CNF_IN_FLOATING << (4 * UART_PIN_RX);
 2ac:	4398                	lw	a4,0(a5)
 2ae:	040006b7          	lui	a3,0x4000
 2b2:	8f55                	or	a4,a4,a3
 2b4:	c398                	sw	a4,0(a5)
	USART1->CTLR1 = USART_Mode_Tx | USART_Mode_Rx | conf->wordlength | conf->parity;
 2b6:	46b1                	li	a3,12
 2b8:	40014737          	lui	a4,0x40014
 2bc:	80d71623          	sh	a3,-2036(a4) # 4001380c <__global_pointer$+0x2001300c>
	USART1->CTLR2 = conf->stopbits;
 2c0:	80071823          	sh	zero,-2032(a4)
	USART1->CTLR3 = (uint16_t)0x0000 | conf->flowctrl;
 2c4:	80071a23          	sh	zero,-2028(a4)
	USART1->BRR = conf->baudrate;
 2c8:	1a100693          	li	a3,417
 2cc:	80d71423          	sh	a3,-2040(a4)
	USART1->CTLR1 |= USART_CTLR1_RXNEIE;
 2d0:	80c75683          	lhu	a3,-2036(a4)
 2d4:	0206e693          	ori	a3,a3,32
 2d8:	80d71623          	sh	a3,-2036(a4)
 2dc:	e000e6b7          	lui	a3,0xe000e
 2e0:	1086a223          	sw	s0,260(a3) # e000e104 <__global_pointer$+0xc000d904>
	USART1->CTLR1 |= CTLR1_UE_Set;
 2e4:	80c75683          	lhu	a3,-2036(a4)
 2e8:	8ed1                	or	a3,a3,a2
 2ea:	80d71623          	sh	a3,-2036(a4)
 2ee:	80c1a683          	lw	a3,-2036(gp) # 2000000c <disp_last_refresh.2>
 2f2:	8081c603          	lbu	a2,-2040(gp) # 20000008 <digit_state.1>
		if(millis() - disp_last_refresh > DISPLAY_REFRESH_MILLIS)
 2f6:	8101a703          	lw	a4,-2032(gp) # 20000010 <g_systick_millis>
 2fa:	4589                	li	a1,2
 2fc:	8f15                	sub	a4,a4,a3
 2fe:	fee5fce3          	bgeu	a1,a4,2f6 <main+0x136>
	if(state == GPIO_LOW) mask = mask << 16;  // Shift by 16 if LOW, to Reset
 302:	00800737          	lui	a4,0x800
 306:	c219                	beqz	a2,30c <main+0x14c>
	uint32_t mask = 0x01 << byte[1];          // Shift by pin number
 308:	08000713          	li	a4,128
	GPIO_PORT_MAP[ byte[0] ]->BSHR = mask;
 30c:	cb98                	sw	a4,16(a5)
 30e:	53c00593          	li	a1,1340
		gpio_digital_write(segment_pin[seg_idx], seg_bit);
 312:	4198                	lw	a4,0(a1)
 314:	4502                	lw	a0,0(sp)
	for(uint16_t seg_idx = 0; seg_idx < 15; seg_idx++)
 316:	0591                	addi	a1,a1,4
	uint32_t mask = 0x01 << byte[1];          // Shift by pin number
 318:	00875693          	srli	a3,a4,0x8
	GPIO_PORT_MAP[ byte[0] ]->BSHR = mask;
 31c:	0ff77713          	zext.b	a4,a4
 320:	070a                	slli	a4,a4,0x2
 322:	972a                	add	a4,a4,a0
 324:	4318                	lw	a4,0(a4)
	uint32_t mask = 0x01 << byte[1];          // Shift by pin number
 326:	00d416b3          	sll	a3,s0,a3
	if(state == GPIO_LOW) mask = mask << 16;  // Shift by 16 if LOW, to Reset
 32a:	06c2                	slli	a3,a3,0x10
	GPIO_PORT_MAP[ byte[0] ]->BSHR = mask;
 32c:	cb14                	sw	a3,16(a4)
 32e:	57800713          	li	a4,1400
 332:	feb710e3          	bne	a4,a1,312 <main+0x152>
	gpio_digital_write(digit_pin, digit_state);
	
	// Blank all the segments to prevent ghosting
	disp_write(0x0000);
	// Write the global segment data to the segment chosen
	disp_write(g_seg_data[digit_state]);
 336:	00161713          	slli	a4,a2,0x1
 33a:	00430693          	addi	a3,t1,4
 33e:	9736                	add	a4,a4,a3
 340:	00075383          	lhu	t2,0(a4) # 800000 <lib_uart.c.02352773+0x7fce95>
 344:	53c00513          	li	a0,1340
 348:	4581                	li	a1,0
		gpio_digital_write(segment_pin[seg_idx], seg_bit);
 34a:	4118                	lw	a4,0(a0)
		uint8_t seg_bit = (seg_data >> seg_idx) & 0x01;
 34c:	40b3d2b3          	sra	t0,t2,a1
	if(state == GPIO_LOW) mask = mask << 16;  // Shift by 16 if LOW, to Reset
 350:	0012f293          	andi	t0,t0,1
	uint32_t mask = 0x01 << byte[1];          // Shift by pin number
 354:	00875693          	srli	a3,a4,0x8
 358:	00d416b3          	sll	a3,s0,a3
	if(state == GPIO_LOW) mask = mask << 16;  // Shift by 16 if LOW, to Reset
 35c:	00029363          	bnez	t0,362 <main+0x1a2>
 360:	06c2                	slli	a3,a3,0x10
	GPIO_PORT_MAP[ byte[0] ]->BSHR = mask;
 362:	4282                	lw	t0,0(sp)
 364:	0ff77713          	zext.b	a4,a4
 368:	070a                	slli	a4,a4,0x2
 36a:	9716                	add	a4,a4,t0
 36c:	4318                	lw	a4,0(a4)
	for(uint16_t seg_idx = 0; seg_idx < 15; seg_idx++)
 36e:	0585                	addi	a1,a1,1
 370:	0511                	addi	a0,a0,4
 372:	cb14                	sw	a3,16(a4)
 374:	473d                	li	a4,15
 376:	fce59ae3          	bne	a1,a4,34a <main+0x18a>
			disp_last_refresh = millis();
 37a:	8101a683          	lw	a3,-2032(gp) # 20000010 <g_systick_millis>

	// Invert the digit_state for the next loop
	digit_state = !digit_state;
 37e:	00163613          	seqz	a2,a2
			disp_last_refresh = millis();
 382:	bf95                	j	2f6 <main+0x136>

00000384 <SysTick_Handler>:
{
 384:	1151                	addi	sp,sp,-12
 386:	c03e                	sw	a5,0(sp)
	SysTick->CMP += SYSTICK_ONE_MILLISECOND;
 388:	e000f7b7          	lui	a5,0xe000f
{
 38c:	c23a                	sw	a4,4(sp)
	SysTick->CMP += SYSTICK_ONE_MILLISECOND;
 38e:	4b98                	lw	a4,16(a5)
{
 390:	c436                	sw	a3,8(sp)
	SysTick->CMP += SYSTICK_ONE_MILLISECOND;
 392:	66b1                	lui	a3,0xc
 394:	b8068693          	addi	a3,a3,-1152 # bb80 <lib_uart.c.02352773+0x8a15>
 398:	9736                	add	a4,a4,a3
 39a:	cb98                	sw	a4,16(a5)
	SysTick->SR = 0x00000000;
 39c:	0007a223          	sw	zero,4(a5) # e000f004 <__global_pointer$+0xc000e804>
	g_systick_millis++;
 3a0:	8101a783          	lw	a5,-2032(gp) # 20000010 <g_systick_millis>
}
 3a4:	46a2                	lw	a3,8(sp)
	g_systick_millis++;
 3a6:	0785                	addi	a5,a5,1
 3a8:	80f1a823          	sw	a5,-2032(gp) # 20000010 <g_systick_millis>
}
 3ac:	4712                	lw	a4,4(sp)
 3ae:	4782                	lw	a5,0(sp)
 3b0:	0131                	addi	sp,sp,12
 3b2:	30200073          	mret

000003b6 <USART1_IRQHandler>:
/// UART Ring Buffer
/// @param None
/// @return None
void USART1_IRQHandler(void) __attribute__((interrupt));
void USART1_IRQHandler(void)
{
 3b6:	1131                	addi	sp,sp,-20
 3b8:	c03e                	sw	a5,0(sp)
	if(USART1->STATR & USART_STATR_RXNE) 
 3ba:	400147b7          	lui	a5,0x40014
{
 3be:	c23a                	sw	a4,4(sp)
	if(USART1->STATR & USART_STATR_RXNE) 
 3c0:	8007d703          	lhu	a4,-2048(a5) # 40013800 <__global_pointer$+0x20013000>
{
 3c4:	c82e                	sw	a1,16(sp)
 3c6:	c632                	sw	a2,12(sp)
 3c8:	c436                	sw	a3,8(sp)
	if(USART1->STATR & USART_STATR_RXNE) 
 3ca:	02077713          	andi	a4,a4,32
 3ce:	c759                	beqz	a4,45c <USART1_IRQHandler+0xa6>
 3d0:	80078793          	addi	a5,a5,-2048
		static uint8_t char_idx = 0;
		bool echo_flag = 0;


		// Read from the DATAR Register to reset the flag
		uint8_t recv = (uint8_t)USART1->DATAR;
 3d4:	0047d783          	lhu	a5,4(a5)

		/*** Handle incomming chars ******************************************/
		// Check if the received byte is a control char
		// Newline and CR are treated the same
		if(recv == ASCII_CONTROL_LINE_FEED || 
 3d8:	46a9                	li	a3,10
		uint8_t recv = (uint8_t)USART1->DATAR;
 3da:	01079713          	slli	a4,a5,0x10
 3de:	0ff7f793          	zext.b	a5,a5
 3e2:	8341                	srli	a4,a4,0x10
		if(recv == ASCII_CONTROL_LINE_FEED || 
 3e4:	00d78563          	beq	a5,a3,3ee <USART1_IRQHandler+0x38>
 3e8:	46b5                	li	a3,13
 3ea:	02d79863          	bne	a5,a3,41a <USART1_IRQHandler+0x64>
		   recv == ASCII_CONTROL_CARRIAGE_RETURN)
		{
			// Clear displays and reset char counter
			g_seg_data[0] = 0x0000;
 3ee:	200007b7          	lui	a5,0x20000
 3f2:	0007a223          	sw	zero,4(a5) # 20000004 <g_seg_data>
			g_seg_data[1] = 0x0000;
			char_idx = 0;
 3f6:	200007b7          	lui	a5,0x20000
 3fa:	00078023          	sb	zero,0(a5) # 20000000 <char_idx.0>


		// Transmit the received byte if the flag is set
		if(echo_flag)
		{
			while(!(USART1->STATR & USART_FLAG_TC));
 3fe:	400147b7          	lui	a5,0x40014
 402:	80078793          	addi	a5,a5,-2048 # 40013800 <__global_pointer$+0x20013000>
 406:	0007d683          	lhu	a3,0(a5)
 40a:	0406f693          	andi	a3,a3,64
 40e:	dee5                	beqz	a3,406 <USART1_IRQHandler+0x50>
			USART1->DATAR = recv;
 410:	0ff77713          	zext.b	a4,a4
 414:	00e79223          	sh	a4,4(a5)
		}
	}
}
 418:	a091                	j	45c <USART1_IRQHandler+0xa6>
		} else if(recv >= 0x20 && recv <= 0x7E)
 41a:	1781                	addi	a5,a5,-32
 41c:	0ff7f613          	zext.b	a2,a5
 420:	05e00693          	li	a3,94
 424:	02c6ec63          	bltu	a3,a2,45c <USART1_IRQHandler+0xa6>
			if(char_idx < 2)
 428:	200005b7          	lui	a1,0x20000
 42c:	0005c683          	lbu	a3,0(a1) # 20000000 <char_idx.0>
 430:	4605                	li	a2,1
 432:	fcd666e3          	bltu	a2,a3,3fe <USART1_IRQHandler+0x48>
				g_seg_data[char_idx] = ascii_font[recv - 0x20];
 436:	20000737          	lui	a4,0x20000
 43a:	00470713          	addi	a4,a4,4 # 20000004 <g_seg_data>
 43e:	00169613          	slli	a2,a3,0x1
 442:	963a                	add	a2,a2,a4
 444:	0786                	slli	a5,a5,0x1
 446:	46c00713          	li	a4,1132
 44a:	973e                	add	a4,a4,a5
 44c:	00075783          	lhu	a5,0(a4)
 450:	00f61023          	sh	a5,0(a2) # 2000 <ch32v003fun.c.bbf629ef+0xdea>
				char_idx++;
 454:	00168793          	addi	a5,a3,1
 458:	00f58023          	sb	a5,0(a1)
}
 45c:	45c2                	lw	a1,16(sp)
 45e:	4632                	lw	a2,12(sp)
 460:	46a2                	lw	a3,8(sp)
 462:	4712                	lw	a4,4(sp)
 464:	4782                	lw	a5,0(sp)
 466:	0151                	addi	sp,sp,20
 468:	30200073          	mret

0000046c <ascii_font>:
 46c:	40060000 12ce0202 242412ed 020009db     ...@......$$....
 47c:	000f0039 12c03fc0 00c02000 24004000     9....?... ...@.$
 48c:	0406243f 008f00db 00ed00e6 240100fd     ?$.............$
 49c:	00e700ff 22001200 00c80c00 50a32100     .......".....!.P
 4ac:	00f702bb 0039128f 0079120f 00bd0071     ......9...y.q...
 4bc:	120900f6 0c70001e 05360038 003f0936     ......p.8.6.6.?.
 4cc:	083f00f3 00ed08f3 003e1201 28362430     ..?.......>.0$6(
 4dc:	00ee2d00 00392409 000f0900 00082800     .-...$9......(..
 4ec:	10580100 00d80878 2058208e 048e14c0     ..X.x.... X ....
 4fc:	10001070 1e002210 10d40030 00dc1050     p...."..0...P...
 50c:	04860170 08880050 001c0078 28142010     p...P...x.... .(
 51c:	028e2d00 21492048 0c891200 000024c0     .-..H I!.....$..

0000052c <GPIO_PORT_MAP>:
 52c:	40010800 00000000 40011000 40011400     ...@.......@...@

0000053c <segment_pin>:
 53c:	00000502 00000602 00000702 00000203     ................
 54c:	00000402 00000100 00000403 00000303     ................
 55c:	00000200 00000003 00000002 00000102     ................
 56c:	00000202 00000302 00000103              ............
