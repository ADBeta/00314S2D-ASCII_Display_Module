
build/00314S2D-ASCII-MKI.elf:     file format elf32-littleriscv


Disassembly of section .init:

00000000 <InterruptVector>:
void InterruptVector()         __attribute__((naked)) __attribute((section(".init"))) __attribute((weak,alias("InterruptVectorDefault")));
void InterruptVectorDefault()  __attribute__((naked)) __attribute((section(".init")));

void InterruptVectorDefault()
{
	asm volatile( "\n\
   0:	0f80006f          	j	f8 <handle_reset>
   4:	00000000          	.word	0x00000000
   8:	00000174          	.word	0x00000174
   c:	00000172          	.word	0x00000172
	...
  30:	00000172          	.word	0x00000172
  34:	00000000          	.word	0x00000000
  38:	00000172          	.word	0x00000172
  3c:	00000000          	.word	0x00000000
  40:	00000172          	.word	0x00000172
  44:	00000172          	.word	0x00000172
  48:	00000172          	.word	0x00000172
  4c:	00000172          	.word	0x00000172
  50:	00000172          	.word	0x00000172
  54:	00000172          	.word	0x00000172
  58:	00000172          	.word	0x00000172
  5c:	00000172          	.word	0x00000172
  60:	00000172          	.word	0x00000172
  64:	00000172          	.word	0x00000172
  68:	00000172          	.word	0x00000172
  6c:	00000172          	.word	0x00000172
  70:	00000172          	.word	0x00000172
  74:	00000172          	.word	0x00000172
  78:	00000172          	.word	0x00000172
  7c:	00000172          	.word	0x00000172
  80:	00000172          	.word	0x00000172
  84:	00000172          	.word	0x00000172
  88:	00000172          	.word	0x00000172
  8c:	00000172          	.word	0x00000172
  90:	00000172          	.word	0x00000172
  94:	00000172          	.word	0x00000172
  98:	00000172          	.word	0x00000172
  9c:	0000                	unimp
	...

Disassembly of section .text:

000000a0 <DelaySysTick>:
#endif

void DelaySysTick( uint32_t n )
{
#ifdef CH32V003
	uint32_t targend = SysTick->CNT + n;
  a0:	e000f737          	lui	a4,0xe000f
  a4:	471c                	lw	a5,8(a4)
  a6:	953e                	add	a0,a0,a5
	while( ((int32_t)( SysTick->CNT - targend )) < 0 );
  a8:	471c                	lw	a5,8(a4)
  aa:	8f89                	sub	a5,a5,a0
  ac:	fe07cee3          	bltz	a5,a8 <DelaySysTick+0x8>
	uint32_t targend = SysTick->CNTL + n;
	while( ((int32_t)( SysTick->CNTL - targend )) < 0 );
#else
	#error DelaySysTick not defined.
#endif
}
  b0:	8082                	ret

000000b2 <gpio_set_mode.constprop.0>:
	
	// Make array of uint8_t from [pin] enum. See definition for details
	uint8_t *byte = (uint8_t *)&pin;
	
	// Set the RCC Register to enable clock on the specified port
	GPIO_RCC->APB2PCENR |= (RCC_APB2PCENR_AFIO | (RCC_APB2PCENR_IOPxEN << byte[0]));
  b2:	400216b7          	lui	a3,0x40021
  b6:	4e90                	lw	a2,24(a3)
  b8:	4791                	li	a5,4
  ba:	00a797b3          	sll	a5,a5,a0
  be:	8fd1                	or	a5,a5,a2
  c0:	0017e793          	ori	a5,a5,1
  c4:	ce9c                	sw	a5,24(a3)
  c6:	0ff57713          	zext.b	a4,a0

	// Clear then set the GPIO Config Register
	GPIO_PORT_MAP[ byte[0] ]->CFGLR &=        ~(0x0F  << (4 * byte[1]));
  ca:	070a                	slli	a4,a4,0x2
  cc:	27000793          	li	a5,624
  d0:	97ba                	add	a5,a5,a4
  d2:	4398                	lw	a4,0(a5)
  d4:	8119                	srli	a0,a0,0x6
  d6:	3fc57513          	andi	a0,a0,1020
  da:	4314                	lw	a3,0(a4)
  dc:	47bd                	li	a5,15
  de:	00a797b3          	sll	a5,a5,a0
  e2:	fff7c793          	not	a5,a5
  e6:	8ff5                	and	a5,a5,a3
  e8:	c31c                	sw	a5,0(a4)
	GPIO_PORT_MAP[ byte[0] ]->CFGLR |=  (mode & 0x0F) << (4 * byte[1]);
  ea:	4314                	lw	a3,0(a4)
  ec:	4785                	li	a5,1
  ee:	00a797b3          	sll	a5,a5,a0
  f2:	8fd5                	or	a5,a5,a3
  f4:	c31c                	sw	a5,0(a4)

	// If [mode] is INPUT_PULLUP or INPUT_PULLDOWN, set the [OUTDR] Register
	if(mode == INPUT_PULLUP || mode == INPUT_PULLDOWN)
		gpio_digital_write(pin, mode >> 4);
}
  f6:	8082                	ret

000000f8 <handle_reset>:
	asm volatile( "\n\
  f8:	20000197          	auipc	gp,0x20000
  fc:	70818193          	addi	gp,gp,1800 # 20000800 <_eusrstack>
 100:	00018113          	mv	sp,gp
 104:	08000513          	li	a0,128
 108:	30051073          	csrw	mstatus,a0
 10c:	468d                	li	a3,3
 10e:	00000517          	auipc	a0,0x0
 112:	ef250513          	addi	a0,a0,-270 # 0 <InterruptVector>
 116:	8d55                	or	a0,a0,a3
 118:	30551073          	csrw	mtvec,a0
asm volatile(
 11c:	20000517          	auipc	a0,0x20000
 120:	ee450513          	addi	a0,a0,-284 # 20000000 <_data_vma>
 124:	20000597          	auipc	a1,0x20000
 128:	edc58593          	addi	a1,a1,-292 # 20000000 <_data_vma>
 12c:	4601                	li	a2,0
 12e:	00b55663          	bge	a0,a1,13a <handle_reset+0x42>
 132:	c110                	sw	a2,0(a0)
 134:	0511                	addi	a0,a0,4
 136:	feb54ee3          	blt	a0,a1,132 <handle_reset+0x3a>
 13a:	2bc00513          	li	a0,700
 13e:	20000597          	auipc	a1,0x20000
 142:	ec258593          	addi	a1,a1,-318 # 20000000 <_data_vma>
 146:	20000617          	auipc	a2,0x20000
 14a:	eba60613          	addi	a2,a2,-326 # 20000000 <_data_vma>
 14e:	00c58863          	beq	a1,a2,15e <handle_reset+0x66>
 152:	4114                	lw	a3,0(a0)
 154:	c194                	sw	a3,0(a1)
 156:	0511                	addi	a0,a0,4
 158:	0591                	addi	a1,a1,4
 15a:	fec59ae3          	bne	a1,a2,14e <handle_reset+0x56>
	SysTick->CTLR = 1;
 15e:	e000f7b7          	lui	a5,0xe000f
 162:	4705                	li	a4,1
 164:	c398                	sw	a4,0(a5)
asm volatile(
 166:	1d600793          	li	a5,470
 16a:	34179073          	csrw	mepc,a5
 16e:	30200073          	mret

00000172 <ADC1_IRQHandler>:
	asm volatile( "1: j 1b" );
 172:	a001                	j	172 <ADC1_IRQHandler>

00000174 <NMI_Handler>:
	RCC->INTR |= RCC_CSSC;	// clear the clock security int flag
 174:	40021737          	lui	a4,0x40021
 178:	471c                	lw	a5,8(a4)
 17a:	008006b7          	lui	a3,0x800
 17e:	8fd5                	or	a5,a5,a3
 180:	c71c                	sw	a5,8(a4)

00000182 <SystemInit>:
	// CH32V003 flash latency
#if defined(CH32X03x)
	FLASH->ACTLR = FLASH_ACTLR_LATENCY_2;                   // +2 Cycle Latency (Recommended per TRM)
#elif defined(CH32V003)
	#if FUNCONF_SYSTEM_CORE_CLOCK > 25000000
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;               // +1 Cycle Latency
 182:	400227b7          	lui	a5,0x40022
 186:	4705                	li	a4,1
 188:	c398                	sw	a4,0(a5)
#if defined(FUNCONF_USE_HSI) && FUNCONF_USE_HSI
	#if defined(CH32V30x) || defined(CH32V20x) || defined(CH32V10x)
		EXTEN->EXTEN_CTR |= EXTEN_PLL_HSI_PRE;
	#endif
	#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL
		RCC->CFGR0 = BASE_CFGR0;
 18a:	400217b7          	lui	a5,0x40021
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 18e:	01080737          	lui	a4,0x1080
		RCC->CFGR0 = BASE_CFGR0;
 192:	0007a223          	sw	zero,4(a5) # 40021004 <_eusrstack+0x20020804>
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 196:	08170713          	addi	a4,a4,129 # 1080081 <lib_gpioctrl.c.e4f3fe8f+0x107dec5>
 19a:	c398                	sw	a4,0(a5)
	#else
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;       		// +1 Cycle Latency
	#endif
#endif

	RCC->INTR  = 0x009F0000;                               // Clear PLL, CSSC, HSE, HSI and LSI ready flags.
 19c:	009f0737          	lui	a4,0x9f0
 1a0:	c798                	sw	a4,8(a5)

#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL
	while((RCC->CTLR & RCC_PLLRDY) == 0);                       	// Wait till PLL is ready
 1a2:	4398                	lw	a4,0(a5)
 1a4:	00671693          	slli	a3,a4,0x6
 1a8:	fe06dde3          	bgez	a3,1a2 <SystemInit+0x20>
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 1ac:	43d8                	lw	a4,4(a5)
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 1ae:	400216b7          	lui	a3,0x40021
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 1b2:	9b71                	andi	a4,a4,-4
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
 1b4:	00276713          	ori	a4,a4,2
 1b8:	c3d8                	sw	a4,4(a5)
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 1ba:	4721                	li	a4,8
 1bc:	42dc                	lw	a5,4(a3)
 1be:	8bb1                	andi	a5,a5,12
 1c0:	fee79ee3          	bne	a5,a4,1bc <SystemInit+0x3a>
	*DMDATA1 = 0x0;
 1c4:	e00007b7          	lui	a5,0xe0000
 1c8:	0e07ac23          	sw	zero,248(a5) # e00000f8 <_eusrstack+0xbffff8f8>
	*DMDATA0 = 0x80;
 1cc:	08000713          	li	a4,128
 1d0:	0ee7aa23          	sw	a4,244(a5)
	SetupUART( UART_BRR );
#endif
#if defined( FUNCONF_USE_DEBUGPRINTF ) && FUNCONF_USE_DEBUGPRINTF
	SetupDebugPrintf();
#endif
}
 1d4:	8082                	ret

000001d6 <main>:
};


/*** Main ********************************************************************/
int main()
{
 1d6:	1151                	addi	sp,sp,-12
 1d8:	c406                	sw	ra,8(sp)
 1da:	c222                	sw	s0,4(sp)
 1dc:	c026                	sw	s1,0(sp)
	SystemInit();
 1de:	3755                	jal	182 <SystemInit>

	// NOTE: Development Phase delay to allow re-programming
	Delay_Ms(5000);
 1e0:	01c9c537          	lui	a0,0x1c9c
 1e4:	38050513          	addi	a0,a0,896 # 1c9c380 <lib_gpioctrl.c.e4f3fe8f+0x1c9a1c4>
 1e8:	3d65                	jal	a0 <DelaySysTick>

	// Enable Alternate GPIO Funtionality and disable SWIO
	RCC->APB2PCENR |= RCC_APB2Periph_AFIO;
 1ea:	40021737          	lui	a4,0x40021
 1ee:	4f1c                	lw	a5,24(a4)
	AFIO->PCFR1    |= 0x04000000;
 1f0:	040006b7          	lui	a3,0x4000
	RCC->APB2PCENR |= RCC_APB2Periph_AFIO;
 1f4:	0017e793          	ori	a5,a5,1
 1f8:	cf1c                	sw	a5,24(a4)
	AFIO->PCFR1    |= 0x04000000;
 1fa:	40010737          	lui	a4,0x40010
 1fe:	435c                	lw	a5,4(a4)
 200:	28000413          	li	s0,640
 204:	8fd5                	or	a5,a5,a3
 206:	c35c                	sw	a5,4(a4)
	// TODO:

	// Set all Segment GPIO to OUTPUT, LOW
	for(uint8_t p = 0; p < 15; p++)
	{
		gpio_set_mode(segment_pin[p], OUTPUT_10MHZ_PP);
 208:	4004                	lw	s1,0(s0)
	for(uint8_t p = 0; p < 15; p++)
 20a:	0411                	addi	s0,s0,4
		gpio_set_mode(segment_pin[p], OUTPUT_10MHZ_PP);
 20c:	8526                	mv	a0,s1
 20e:	3555                	jal	b2 <gpio_set_mode.constprop.0>
inline void gpio_digital_write(const GPIO_PIN pin, const GPIO_STATE state)
{
	// Make array of uint8_t from [pin] enum. See definition for details
	uint8_t *byte = (uint8_t *)&pin;

	uint32_t mask = 0x01 << byte[1];          // Shift by pin number
 210:	0084d793          	srli	a5,s1,0x8
 214:	4705                	li	a4,1
 216:	00f71733          	sll	a4,a4,a5
	if(state == GPIO_LOW) mask = mask << 16;  // Shift by 16 if LOW, to Reset

	GPIO_PORT_MAP[ byte[0] ]->BSHR = mask;
 21a:	0ff4f493          	zext.b	s1,s1
 21e:	048a                	slli	s1,s1,0x2
 220:	27000793          	li	a5,624
 224:	97a6                	add	a5,a5,s1
 226:	439c                	lw	a5,0(a5)
 228:	cb98                	sw	a4,16(a5)
	for(uint8_t p = 0; p < 15; p++)
 22a:	2bc00693          	li	a3,700
 22e:	fcd41de3          	bne	s0,a3,208 <main+0x32>
		gpio_digital_write(segment_pin[p], GPIO_HIGH);

	}

	// Set the Display Control Pin to OUTPUT, LOW
	gpio_set_mode(digit_pin, OUTPUT_10MHZ_PP);
 232:	70300513          	li	a0,1795
 236:	3db5                	jal	b2 <gpio_set_mode.constprop.0>
 238:	400117b7          	lui	a5,0x40011
 23c:	40078793          	addi	a5,a5,1024 # 40011400 <_eusrstack+0x20010c00>
 240:	00800737          	lui	a4,0x800
 244:	cb98                	sw	a4,16(a5)



	while(1)
	{
		Delay_Ms(100);
 246:	00092537          	lui	a0,0x92
 24a:	7c050513          	addi	a0,a0,1984 # 927c0 <lib_gpioctrl.c.e4f3fe8f+0x90604>
 24e:	3d89                	jal	a0 <DelaySysTick>
 250:	40011437          	lui	s0,0x40011
 254:	08000793          	li	a5,128
 258:	40040413          	addi	s0,s0,1024 # 40011400 <_eusrstack+0x20010c00>
		gpio_digital_write(digit_pin, GPIO_HIGH);
		Delay_Ms(100);
 25c:	00092537          	lui	a0,0x92
 260:	c81c                	sw	a5,16(s0)
 262:	7c050513          	addi	a0,a0,1984 # 927c0 <lib_gpioctrl.c.e4f3fe8f+0x90604>
 266:	3d2d                	jal	a0 <DelaySysTick>
 268:	008007b7          	lui	a5,0x800
 26c:	c81c                	sw	a5,16(s0)
	while(1)
 26e:	bfe1                	j	246 <main+0x70>

00000270 <GPIO_PORT_MAP>:
 270:	0800 4001 0000 0000 1000 4001 1400 4001     ...@.......@...@

00000280 <segment_pin>:
 280:	0502 0000 0602 0000 0702 0000 0203 0000     ................
 290:	0402 0000 0100 0000 0403 0000 0303 0000     ................
 2a0:	0200 0000 0003 0000 0002 0000 0102 0000     ................
 2b0:	0202 0000 0302 0000 0103 0000               ............
